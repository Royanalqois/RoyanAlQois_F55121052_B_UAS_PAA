# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kJoVqTxjXzXeB-7_qSTJ_7Y-1qedqZyE
"""

import time

# Fungsi untuk menghitung shortest path menggunakan algoritma TSP
def tsp_algorithm(graph, start_vertex):
    num_vertices = len(graph)
    vertex_set = set(range(num_vertices))
    memo = {}

    # Rekursif dengan memoization
    def tsp_helper(curr_vertex, vertex_set):
        # Base case
        if len(vertex_set) == 1:
            return graph[curr_vertex][start_vertex]

        # Mengecek memoization
        memo_key = (curr_vertex, tuple(vertex_set))
        if memo_key in memo:
            return memo[memo_key]

        min_distance = float('inf')
        for next_vertex in vertex_set:
            if next_vertex == start_vertex or next_vertex == curr_vertex:
                continue
            distance = graph[curr_vertex][next_vertex] + tsp_helper(next_vertex, vertex_set - {next_vertex})
            min_distance = min(min_distance, distance)

        # Menyimpan hasil ke dalam memo
        memo[memo_key] = min_distance
        return min_distance

    # Panggil fungsi rekursif
    shortest_path = tsp_helper(start_vertex, vertex_set)
    return shortest_path

# Fungsi untuk menghitung shortest path menggunakan algoritma Dijkstra
def dijkstra_algorithm(graph, start_vertex):
    num_vertices = len(graph)
    dist = [float('inf')] * num_vertices
    dist[start_vertex] = 0
    visited = [False] * num_vertices

    # Proses iteratif untuk mencari shortest path
    for _ in range(num_vertices):
        min_dist = float('inf')
        min_vertex = -1

        # Mencari vertex dengan jarak terpendek
        for v in range(num_vertices):
            if not visited[v] and dist[v] < min_dist:
                min_dist = dist[v]
                min_vertex = v

        visited[min_vertex] = True

        # Update jarak terpendek untuk tetangga yang belum dikunjungi
        for v in range(num_vertices):
            if not visited[v] and graph[min_vertex][v] > 0:
                new_dist = dist[min_vertex] + graph[min_vertex][v]
                if new_dist < dist[v]:
                    dist[v] = new_dist

    shortest_path = dist
    return shortest_path

# Fungsi untuk mengambil input graf dari pengguna
def get_graph_from_user():
    num_vertices = int(input("Masukkan jumlah vertex dalam graf: "))
    graph = []
    for i in range(num_vertices):
        row = list(map(int, input(f"Masukkan baris ke-{i+1} dari graf (pisahkan dengan spasi): ").split()))
        graph.append(row)
    return graph

# Fungsi utama
def main():
    print("=================================")
    print("=        Royan Al Qois         =")
    print("=          F55121052            =")
    print("=           Kelas B             =")
    print("=================================")
    print("\n\nProgram Perhitungan Shortest Path")

    while True:
        print("==========================================")
        print("= Pilihan:                               =")
        print("==========================================")
        print("= 1. = Travelling Salesman Problem (TSP) =")
        print("= 2. = Dijkstra                          =")
        print("= 0. = Keluar                            =")
        print("==========================================")
        choice = int(input("Masukkan pilihan Anda: "))

        if choice == 1:
            print("\n--- Travelling Salesman Problem (TSP) ---")
            graph = get_graph_from_user()

            start_time = time.time()
            shortest_path = tsp_algorithm(graph, 0)
            end_time = time.time()

            print("\nHasil:")
            print("Jalur terpendek: ", shortest_path)
            print("Waktu komputasi: ", end_time - start_time, "detik")

        elif choice == 2:
            print("\n--- Dijkstra ---")
            graph = get_graph_from_user()

            start_vertex = int(input("Masukkan vertex awal: "))

            start_time = time.time()
            shortest_path = dijkstra_algorithm(graph, start_vertex)
            end_time = time.time()

            print("\nHasil:")
            print("Jarak terpendek dari vertex awal:")
            for i in range(len(shortest_path)):
                print(f"Vertex {i}: {shortest_path[i]}")
            print("Waktu komputasi: ", end_time - start_time, "detik")

        elif choice == 0:
            print("Terima kasih telah menggunakan program ini!")
            break

        else:
            print("Pilihan tidak valid. Silakan coba lagi.")


if __name__ == '__main__':
    main()